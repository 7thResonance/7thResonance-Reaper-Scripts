// Zero-latency 3-band saturation JSFX
// - 3 bands via two Linkwitz-Riley style crossovers (implemented as cascaded 2nd-order Butterworth LPs)
// - per-band saturation (simple soft saturation derived from Tube-like idea)
// - output gain (dB) and mix (dry/wet)
// - zero added latency (IIR filters only)

desc:Tubify

slider1:0.0<-24,24,0.1>Input
slider2:100<0,100,1>Mix
slider4:100<20,2000,1>Low/Mid Xover (Hz)
slider5:400<100,20000,1>Mid/High Xover (Hz)
slider6:8000<200,20000,1>Upper Xover (Hz)
slider8:0.0<0,10,0.01>Low Drive
slider9:0.0<0,10,0.01>Mid Drive
slider10:0.0<0,10,0.01>Upper-Mid Drive
slider11:0.0<0,10,0.01>High Drive
// (slot 12 left empty for UI separation)
slider13:0.0<-12,12,0.1>Post Low Gain (dB)
slider14:0.0<-12,12,0.1>Post Low-Mid Gain (dB)
slider15:0.0<-12,12,0.1>Post Mid-Upper Gain (dB)
slider16:0.0<-12,12,0.1>Post High Gain (dB)
slider17:0.0<-24,24,0.1>Output Gain (dB)

in_pin:left input
in_pin:right input
out_pin:left output
out_pin:right output

@init
// filter states and default Q (Butterworth)
Q = 0.7071067811865476;

// per-sample state initialization for all biquad stages (set to 0 implicitly)
lpf1_s1_x1L; lpf1_s1_x2L; lpf1_s1_y1L; lpf1_s1_y2L;
lpf1_s2_x1L; lpf1_s2_x2L; lpf1_s2_y1L; lpf1_s2_y2L;

lpf1_s1_x1R; lpf1_s1_x2R; lpf1_s1_y1R; lpf1_s1_y2R;
lpf1_s2_x1R; lpf1_s2_x2R; lpf1_s2_y1R; lpf1_s2_y2R;

lpf2_s1_x1L; lpf2_s1_x2L; lpf2_s1_y1L; lpf2_s1_y2L;
lpf2_s2_x1L; lpf2_s2_x2L; lpf2_s2_y1L; lpf2_s2_y2L;

lpf2_s1_x1R; lpf2_s1_x2R; lpf2_s1_y1R; lpf2_s1_y2R;
lpf2_s2_x1R; lpf2_s2_x2R; lpf2_s2_y1R; lpf2_s2_y2R;

// third crossover filter states (for 4-band split)
lpf3_s1_x1L; lpf3_s1_x2L; lpf3_s1_y1L; lpf3_s1_y2L;
lpf3_s2_x1L; lpf3_s2_x2L; lpf3_s2_y1L; lpf3_s2_y2L;

lpf3_s1_x1R; lpf3_s1_x2R; lpf3_s1_y1R; lpf3_s1_y2R;
lpf3_s2_x1R; lpf3_s2_x2R; lpf3_s2_y1R; lpf3_s2_y2R;

// biquad coefficients placeholders
b0; b1; b2; a1; a2;
b0_2; b1_2; b2_2; a1_2; a2_2;
b0_3; b1_3; b2_3; a1_3; a2_3;



@block
// read sliders (per-block)
// slider1 is now in dB; convert to linear gain for processing
inputPadDB = slider1;
inputPad = pow(10.0, inputPadDB * 0.05);
// slider2 is percent 0..100; convert to 0..1 mix
mix = slider2 * 0.01;
outGainDB = slider17;
// xovers now at sliders 4,5,6
xover1 = slider4;
xover2 = slider5;
// xover3 now uses slider6
xover3 = slider6;
// drives: low=8, mid=9, upper-mid=10, high=11
lowDrive = slider8;
midDrive = slider9;
upperDrive = slider10;
highDrive = slider11;


// Define frequency bounds used for mapping
min_x1 = 20.0; max_x1 = 2000.0;
min_x2 = 100.0; max_x2 = 20000.0;
min_x3 = 200.0; max_x3 = 20000.0;
// read slider frequencies directly (Hz) from renumbered sliders
xover1 = slider4;
xover2 = slider5;
xover3 = slider6;
// clamp to bounds
(xover1 < min_x1) ? xover1 = min_x1 : (xover1 > max_x1) ? xover1 = max_x1 : xover1;
(xover2 < min_x2) ? xover2 = min_x2 : (xover2 > max_x2) ? xover2 = max_x2 : xover2;
(xover3 < min_x3) ? xover3 = min_x3 : (xover3 > max_x3) ? xover3 = max_x3 : xover3;
// ensure sensible spacing between crossovers (in Hz) and enforce slider ordering
minSpacing = 20.0; // Hz
// if the low/mid is set too high, push it down; if mid/high is set too low, push it up to maintain spacing
(xover2 < xover1 + minSpacing) ? (
  // decide which slider moved more recently by comparing to previous slider values if available
  // fallback: nudge the upper slider up
  xover2 = xover1 + minSpacing
) : 0;
(xover3 < xover2 + minSpacing) ? (
  xover3 = xover2 + minSpacing
) : 0;
// write corrected values back to sliders so they don't cross in the UI/automation
slider4 = xover1;
slider5 = xover2;
slider6 = xover3;

// precompute linear gain
outGain = pow(10.0, outGainDB * 0.05);



// map drive sliders (0..10) to dB then to linear gain. 3 dB per slider unit => 0..30 dB at 10
lowGain = pow(10.0, (lowDrive * 3.0) * 0.05);
midGain = pow(10.0, (midDrive * 3.0) * 0.05);
highGain = pow(10.0, (highDrive * 3.0) * 0.05);
upperGain = pow(10.0, (upperDrive * 3.0) * 0.05);

// precompute per-band asymmetry factors (used by the fast soft-clipper)
asym_low = lowDrive * 0.02;
asym_mid = midDrive * 0.02;
asym_upper = upperDrive * 0.02;
asym_high = highDrive * 0.02;

// post-saturation per-band gains (dB -> linear)
postLowGainDB = slider13;
postLowMidGainDB = slider14;
postMidUpperGainDB = slider15;
postHighGainDB = slider16;
postLowGain = pow(10.0, postLowGainDB * 0.05);
postLowMidGain = pow(10.0, postLowMidGainDB * 0.05);
postMidUpperGain = pow(10.0, postMidUpperGainDB * 0.05);
postHighGain = pow(10.0, postHighGainDB * 0.05);

// precompute lowpass biquad coefficients (RBJ cookbook) for f = xover1 and f = xover2
// We'll compute coefficients for second-order Butterworth (Q=0.7071) and cascade two identical stages
// stage coefficients for xover1
omega = 2.0 * 3.141592653589793 * xover1 / srate;
sn = sin(omega);
cs = cos(omega); 
alpha = sn / (2.0 * Q);
b0_tmp = (1.0 - cs) * 0.5;
b1_tmp = 1.0 - cs;
b2_tmp = (1.0 - cs) * 0.5;
a0_tmp = 1.0 + alpha;
a1_tmp = -2.0 * cs;
a2_tmp = 1.0 - alpha;
b0_lp1 = b0_tmp / a0_tmp; b1_lp1 = b1_tmp / a0_tmp; b2_lp1 = b2_tmp / a0_tmp;
a1_lp1 = a1_tmp / a0_tmp; a2_lp1 = a2_tmp / a0_tmp;

// stage coefficients for xover2
omega2 = 2.0 * 3.141592653589793 * xover2 / srate;
sn2 = sin(omega2);
cs2 = cos(omega2);
alpha2 = sn2 / (2.0 * Q);
b0_tmp2 = (1.0 - cs2) * 0.5;
b1_tmp2 = 1.0 - cs2;
b2_tmp2 = (1.0 - cs2) * 0.5;
a0_tmp2 = 1.0 + alpha2;
a1_tmp2 = -2.0 * cs2;
a2_tmp2 = 1.0 - alpha2;
b0_lp2 = b0_tmp2 / a0_tmp2; b1_lp2 = b1_tmp2 / a0_tmp2; b2_lp2 = b2_tmp2 / a0_tmp2;
a1_lp2 = a1_tmp2 / a0_tmp2; a2_lp2 = a2_tmp2 / a0_tmp2;

// stage coefficients for xover3
omega3 = 2.0 * 3.141592653589793 * xover3 / srate;
sn3 = sin(omega3);
cs3 = cos(omega3);
alpha3 = sn3 / (2.0 * Q);
b0_tmp3 = (1.0 - cs3) * 0.5;
b1_tmp3 = 1.0 - cs3;
b2_tmp3 = (1.0 - cs3) * 0.5;
a0_tmp3 = 1.0 + alpha3;
a1_tmp3 = -2.0 * cs3;
a2_tmp3 = 1.0 - alpha3;
b0_lp3 = b0_tmp3 / a0_tmp3; b1_lp3 = b1_tmp3 / a0_tmp3; b2_lp3 = b2_tmp3 / a0_tmp3;
a1_lp3 = a1_tmp3 / a0_tmp3; a2_lp3 = a2_tmp3 / a0_tmp3;

// We'll use the same LP coefficients for both cascaded stages (Linkwitz-Riley style)
b0_stage = b0_lp1; b1_stage = b1_lp1; b2_stage = b2_lp1; a1_stage = a1_lp1; a2_stage = a2_lp1;
b0_stage2 = b0_lp2; b1_stage2 = b1_lp2; b2_stage2 = b2_lp2; a1_stage2 = a1_lp2; a2_stage2 = a2_lp2;
b0_stage3 = b0_lp3; b1_stage3 = b1_lp3; b2_stage3 = b2_lp3; a1_stage3 = a1_lp3; a2_stage3 = a2_lp3;


@sample
// store original dry samples for correct bypass/dry mix
origDryL = spl0;
origDryR = spl1;


// use dryL/dryR for the processing chain (they will be scaled by inputPad below)
dryL = origDryL;
dryR = origDryR;

// apply input pad
(inPadTemp = inputPad) < 1.0 ? (dryL *= inPadTemp; dryR *= inPadTemp;) : (dryL *= inPadTemp; dryR *= inPadTemp;);


// --------------------------------------------------------------------------------
// compute LP4 @ xover1 (low band) and LP4 @ xover2 (low+mid combined) by cascading two 2nd-order LPs
// We'll implement LP4_f1(input) => low1, LP4_f2(input) => low2
x = dryL;

// -- Left channel LP4 at xover1 (two cascaded stages with coeffs b0_stage etc)
in0 = x;
y_stage1 = b0_stage*in0 + b1_stage*lpf1_s1_x1L + b2_stage*lpf1_s1_x2L - a1_stage*lpf1_s1_y1L - a2_stage*lpf1_s1_y2L;
lpf1_s1_x2L = lpf1_s1_x1L; lpf1_s1_x1L = in0;
lpf1_s1_y2L = lpf1_s1_y1L; lpf1_s1_y1L = y_stage1;

y_stage2 = b0_stage*y_stage1 + b1_stage*lpf1_s2_x1L + b2_stage*lpf1_s2_x2L - a1_stage*lpf1_s2_y1L - a2_stage*lpf1_s2_y2L;
lpf1_s2_x2L = lpf1_s2_x1L; lpf1_s2_x1L = y_stage1;
lpf1_s2_y2L = lpf1_s2_y1L; lpf1_s2_y1L = y_stage2;

low1L = y_stage2;

// -- Right channel LP4 at xover1
x = dryR;
in0 = x;
y_stage1 = b0_stage*in0 + b1_stage*lpf1_s1_x1R + b2_stage*lpf1_s1_x2R - a1_stage*lpf1_s1_y1R - a2_stage*lpf1_s1_y2R;
lpf1_s1_x2R = lpf1_s1_x1R; lpf1_s1_x1R = in0;
lpf1_s1_y2R = lpf1_s1_y1R; lpf1_s1_y1R = y_stage1;

y_stage2 = b0_stage*y_stage1 + b1_stage*lpf1_s2_x1R + b2_stage*lpf1_s2_x2R - a1_stage*lpf1_s2_y1R - a2_stage*lpf1_s2_y2R;
lpf1_s2_x2R = lpf1_s2_x1R; lpf1_s2_x1R = y_stage1;
lpf1_s2_y2R = lpf1_s2_y1R; lpf1_s2_y1R = y_stage2;

low1R = y_stage2;

// --------------------------------------------------------------------------------
// LP4 at xover2 (low2 = low frequencies up to xover2)
x = dryL;
in0 = x;
y_stage1 = b0_stage2*in0 + b1_stage2*lpf2_s1_x1L + b2_stage2*lpf2_s1_x2L - a1_stage2*lpf2_s1_y1L - a2_stage2*lpf2_s1_y2L;
lpf2_s1_x2L = lpf2_s1_x1L; lpf2_s1_x1L = in0;
lpf2_s1_y2L = lpf2_s1_y1L; lpf2_s1_y1L = y_stage1;

y_stage2 = b0_stage2*y_stage1 + b1_stage2*lpf2_s2_x1L + b2_stage2*lpf2_s2_x2L - a1_stage2*lpf2_s2_y1L - a2_stage2*lpf2_s2_y2L;
lpf2_s2_x2L = lpf2_s2_x1L; lpf2_s2_x1L = y_stage1;
lpf2_s2_y2L = lpf2_s2_y1L; lpf2_s2_y1L = y_stage2;

low2L = y_stage2;

x = dryR;
in0 = x;
y_stage1 = b0_stage2*in0 + b1_stage2*lpf2_s1_x1R + b2_stage2*lpf2_s1_x2R - a1_stage2*lpf2_s1_y1R - a2_stage2*lpf2_s1_y2R;
lpf2_s1_x2R = lpf2_s1_x1R; lpf2_s1_x1R = in0;
lpf2_s1_y2R = lpf2_s1_y1R; lpf2_s1_y1R = y_stage1;

y_stage2 = b0_stage2*y_stage1 + b1_stage2*lpf2_s2_x1R + b2_stage2*lpf2_s2_x2R - a1_stage2*lpf2_s2_y1R - a2_stage2*lpf2_s2_y2R;
lpf2_s2_x2R = lpf2_s2_x1R; lpf2_s2_x1R = y_stage1;
lpf2_s2_y2R = lpf2_s2_y1R; lpf2_s2_y1R = y_stage2;

low2R = y_stage2;

// --------------------------------------------------------------------------------
// LP4 at xover3 (low3 = low frequencies up to xover3)
x = dryL;
in0 = x;
y_stage1 = b0_stage3*in0 + b1_stage3*lpf3_s1_x1L + b2_stage3*lpf3_s1_x2L - a1_stage3*lpf3_s1_y1L - a2_stage3*lpf3_s1_y2L;
lpf3_s1_x2L = lpf3_s1_x1L; lpf3_s1_x1L = in0;
lpf3_s1_y2L = lpf3_s1_y1L; lpf3_s1_y1L = y_stage1;

y_stage2 = b0_stage3*y_stage1 + b1_stage3*lpf3_s2_x1L + b2_stage3*lpf3_s2_x2L - a1_stage3*lpf3_s2_y1L - a2_stage3*lpf3_s2_y2L;
lpf3_s2_x2L = lpf3_s2_x1L; lpf3_s2_x1L = y_stage1;
lpf3_s2_y2L = lpf3_s2_y1L; lpf3_s2_y1L = y_stage2;

low3L = y_stage2;

x = dryR;
in0 = x;
y_stage1 = b0_stage3*in0 + b1_stage3*lpf3_s1_x1R + b2_stage3*lpf3_s1_x2R - a1_stage3*lpf3_s1_y1R - a2_stage3*lpf3_s1_y2R;
lpf3_s1_x2R = lpf3_s1_x1R; lpf3_s1_x1R = in0;
lpf3_s1_y2R = lpf3_s1_y1R; lpf3_s1_y1R = y_stage1;

y_stage2 = b0_stage3*y_stage1 + b1_stage3*lpf3_s2_x1R + b2_stage3*lpf3_s2_x2R - a1_stage3*lpf3_s2_y1R - a2_stage3*lpf3_s2_y2R;
lpf3_s2_x2R = lpf3_s2_x1R; lpf3_s2_x1R = y_stage1;
lpf3_s2_y2R = lpf3_s2_y1R; lpf3_s2_y1R = y_stage2;

low3R = y_stage2;

// --------------------------------------------------------------------------------
// derive bands:
// lowBand = low1
// midBand = low2 - low1
// highBand = input - low2

// For 4 bands (low, low-mid, mid-upper, high):
// lowBand = low1
// lowMid = low2 - low1
// midUpper = low3 - low2
// high = input - low3

lowBandL = low1L;
lowBandR = low1R;
lowMidL = low2L - low1L;
lowMidR = low2R - low1R;
midUpperL = low3L - low2L;
midUpperR = low3R - low2R;
highBandL = dryL - low3L;
highBandR = dryR - low3R;

// --------------------------------------------------------------------------------
// per-band saturation processing (simple atan-based saturator)
// Low band
// simple atan-based saturator for low band
inputSampleL = lowBandL * lowGain;
inputSampleR = lowBandR * lowGain;
// fast soft-clipper: x / (1 + |x|)
tmpL = abs(inputSampleL);
tmpR = abs(inputSampleR);
inputSampleL = inputSampleL / (1.0 + tmpL);
inputSampleR = inputSampleR / (1.0 + tmpR);
// asymmetry (positive-side boost)
inputSampleL += inputSampleL * asym_low * (inputSampleL > 0.0);
inputSampleR += inputSampleR * asym_low * (inputSampleR > 0.0);
lowProcL = inputSampleL; lowProcR = inputSampleR;


//////////////////////////// Mid band
// simple atan-based saturator for mid band
inputSampleL = lowMidL * midGain; inputSampleR = lowMidR * midGain;
tmpL = abs(inputSampleL);
tmpR = abs(inputSampleR);
inputSampleL = inputSampleL / (1.0 + tmpL);
inputSampleR = inputSampleR / (1.0 + tmpR);
inputSampleL += inputSampleL * asym_mid * (inputSampleL > 0.0);
inputSampleR += inputSampleR * asym_mid * (inputSampleR > 0.0);
midProcL = inputSampleL; midProcR = inputSampleR;


//////////////////////////// Mid-upper
// simple atan-based saturator for mid-upper band
inputSampleL = midUpperL * upperGain; inputSampleR = midUpperR * upperGain;
tmpL = abs(inputSampleL);
tmpR = abs(inputSampleR);
inputSampleL = inputSampleL / (1.0 + tmpL);
inputSampleR = inputSampleR / (1.0 + tmpR);
inputSampleL += inputSampleL * asym_upper * (inputSampleL > 0.0);
inputSampleR += inputSampleR * asym_upper * (inputSampleR > 0.0);
midUpperProcL = inputSampleL; midUpperProcR = inputSampleR;

//////////////////////////// High band
// simple atan-based saturator for high band
inputSampleL = highBandL * highGain; inputSampleR = highBandR * highGain;
tmpL = abs(inputSampleL);
tmpR = abs(inputSampleR);
inputSampleL = inputSampleL / (1.0 + tmpL);
inputSampleR = inputSampleR / (1.0 + tmpR);
inputSampleL += inputSampleL * asym_high * (inputSampleL > 0.0);
inputSampleR += inputSampleR * asym_high * (inputSampleR > 0.0);
highProcL = inputSampleL; highProcR = inputSampleR;


// apply post-saturation per-band gains
lowProcL *= postLowGain; lowProcR *= postLowGain;
midProcL *= postLowMidGain; midProcR *= postLowMidGain;
midUpperProcL *= postMidUpperGain; midUpperProcR *= postMidUpperGain;
highProcL *= postHighGain; highProcR *= postHighGain;

// now sum bands back for 4-band
processedL = lowProcL + midProcL + midUpperProcL + highProcL;
processedR = lowProcR + midProcR + midUpperProcR + highProcR;

// apply output gain
processedL *= outGain;
processedR *= outGain;

// mix with dry â€” no bypass control, just mix processed and dry per slider2
finalProcL = processedL;
finalProcR = processedR;

spl0 = (origDryL * (1.0 - mix)) + (finalProcL * mix);
spl1 = (origDryR * (1.0 - mix)) + (finalProcR * mix);